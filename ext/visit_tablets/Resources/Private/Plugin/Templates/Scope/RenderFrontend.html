<html  xmlns:f="http://typo3.org/ns/TYPO3/CMS/Fluid/ViewHelpers" data-namespace-typo3-fluid="true">

    <f:layout name="Fernrohr" />

    <f:section name="title">Titel Sektion</f:section>
    <f:section name="main">
        <style type="text/css">
            #scopeContainer #overlay{
                width: <f:format.raw>{config.maxxpx}</f:format.raw>px;
                height: <f:format.raw>{config.maxypx}</f:format.raw>px;
            }
        </style>
        <f:comment>WHAT?! For some reason we need to address config via this to access it afterwards?</f:comment>
        <f:for each="{config}" as="conf" key="k"></f:for>
        <div class="full">
            <div id="scopeContainer">
                <video autoplay="true" id="camrtc" class="full"></video>
                <div id="overlay" class="full">
                    <f:for each="{pois}" as="poi">
                        <div class="poi" id="poi-{poi.uid}" style="
transform: translate({poi.y - poi.radiusHalf}px,{poi.x - poi.radiusHalf}px);height:{poi.radius}px;width:{poi.radius}px;">
                            <div class="inside">
                                <f:if condition="{config.debugmode} && false">
                                    <f:then>
                                        {poi.title}
                                        <br />X: {poi.x}
                                        <br />Y: {poi.y}
                                        <br />UID: {poi.uid}
                                    </f:then>
                                    <f:else>
                                        <figure>
                                            <img class="poi-icon" src="/typo3conf/ext/visit_tablets/Resources/Public/Icons/Scope/Festung_ICON.svg" />
                                        </figure>
                                    </f:else>
                                </f:if>
                            </div>
                        </div>
                    </f:for>
                </div>
                <f:if condition="{config.debugmode}">
                    <div id="debug">
                        <p>
                            maxx: {config.maxx}
                            <br />maxy: {config.maxy}
                            <br />maxxpx: {config.maxxpx}
                            <br />maxypx: {config.maxypx}
                            <br />CurrentX: <span id="currentX"></span>
                            <br />CurrentY: <span id="currentY"></span>
                            <br />Target: <span id="target">-</span>
                        </p>
                        <h3>POIs</h3>
                        <table>
                            <tr>
                                <th>UID</th>
                                <th>Title</th>
                                <th>Radius</th>
                                <th>X</th>
                                <th>Y</th>
                            </tr>
                            <f:for each="{pois}" as="poi">
                                <tr>
                                    <td>{poi.uid}</td>
                                    <td>{poi.title}</td>
                                    <td>{poi.radius}</td>
                                    <td>{poi.x}</td>
                                    <td>{poi.y}</td>
                                </tr>
                            </f:for>
                        </table>
                    </div>
                    <div id="crosshair"></div>
                </f:if>
            </div>
        </div>
        <div class="content-holder{f:if(condition:'{config.debugmode}', then:' debug')}">
            <div class="scroller">
                <f:for each="{pois}" as="datapoint">
                    <div class="datapoint" id="datapoint-id-{datapoint.uid}" data-id="{datapoint.uid}" >

                        <h1 class="lang-de">{datapoint.title}</h1>

                        <h2 class="lang-de">{datapoint.subTitle}</h2>

                        <figure>
                            <f:render partial="RenderMedia" arguments="{media: datapoint.media}"/>
                        </figure>

                        <div class="desc-text lang-de">
                            <f:format.raw>
                                {datapoint.description}
                            </f:format.raw>
                        </div>
                    </div>
                </f:for>
            </div>
        </div>
        <script src="typo3conf/ext/visit_tablets/Resources/Public/Backend/vendors/encoder/jquery-2.1.4.min.js"></script> 
        <script src="typo3conf/ext/visit_tablets/Resources/Public/Backend/vendors/encoder/sha256.min.js"></script> 
        <script src="typo3conf/ext/visit_tablets/Resources/Public/Backend/vendors/encoder/phidget22.min.js"></script> 
        <script>
            var video = document.querySelector("#camrtc");

            if (navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({video: true})
                        .then(function (stream) {
                            video.srcObject = stream;
                        })
                        .catch(function (err0r) {
                            console.log("Something went wrong!\n" + err0r);
                            alert("No Webcam Detected!")
                        });
            }
            
            debugmode = <f:format.raw>{config.debugmode}</f:format.raw>;
            hysteresisFactor = 0.25;
            
            jsonPois = <f:format.raw>{jsonPois}</f:format.raw>;
            
            xMax = <f:format.raw>{config.maxx}</f:format.raw>;
            yMax = <f:format.raw>{config.maxy}</f:format.raw>;
            currentX = 0;
            currentY = 0;
            crosshairScreenOffsetX = 0;
            crosshairScreenOffsetY = 0;
            resetCrosshairPosition();
            
            var phid;

            $(document).ready(function () {
                var conn = new phidget22.Connection(<f:format.raw>{config.sensorport}</f:format.raw>, '<f:format.raw>{config.sensorhost}</f:format.raw>');

                var encoderX = new phidget22.Encoder();
                encoderX.onError = onError;
                encoderX.name = "X-Channel";
                encoderX.onStateChange = posXChange;
                encoderX.onPropertyChange = posXChange;
                encoderX.onPositionChange = posXChange;
                encoderX.onAttach = onEncoderAttach;

                var encoderY = new phidget22.Encoder();
                encoderY.onError = onError;
                encoderY.name = "Y-Channel";
                encoderY.onStateChange = posYChange;
                encoderY.onPropertyChange = posYChange;
                encoderY.onPositionChange = posYChange;
                encoderY.onAttach = onEncoderAttach;
                
                var endXTop = new phidget22.DigitalInput();
                endXTop.onError = onError;
                endXTop.name = "X Endstop Top";
                endXTop.onStateChange = endXTopReached;
                endXTop.onPropertyChange = endXTopReached;
                endXTop.onAttach = onButtonAttach;

                var endXBottom = new phidget22.DigitalInput();
                endXBottom.onError = onError;
                endXBottom.name = "X Endstop Bottom";
                endXBottom.onStateChange = endXBottomReached;
                endXBottom.onPropertyChange = endXBottomReached;
                endXBottom.onAttach = onButtonAttach;

                var endYTop = new phidget22.DigitalInput();
                endYTop.onError = onError;
                endYTop.name = "Y Endstop Top";
                endYTop.onStateChange = endYTopReached;
                endYTop.onPropertyChange = endYTopReached;
                endYTop.onAttach = onButtonAttach;

                var endYBottom = new phidget22.DigitalInput();
                endYBottom.onError = onError;
                endYBottom.name = "X Endstop Bottom";
                endYBottom.onStateChange = endYBottomReached;
                endYBottom.onPropertyChange = endYBottomReached;
                endYBottom.onAttach = onButtonAttach;

                encoderX.onDetach = function (ch) {
                    console.log("detached - " + ch)
                }

                conn.connect().then(function () {
                    console.log('connected');
                    encoderX.open().then(function (encoderX) {
                        console.log('channel X open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                    encoderY.open().then(function (encoderY) {
                        console.log('channel Y open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                    endXTop.open().then(function (endXTop) {
                        console.log('endstop x + open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                    endXBottom.open().then(function (endXBottom) {
                        console.log('endstop x - open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                    endYTop.open().then(function (endYTop) {
                        console.log('endstop y + open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                    endYBottom.open().then(function (endYBottom) {
                        console.log('endstop y - open');
                    }).catch(function (err) {
                        console.log('failed to open the channel:' + err);
                    });
                }).catch(function (err) {
                    alert('failed to connect to server:' + err);
                });
                ;
            });

            function onEncoderAttach(ch) {
                console.log(ch.name + ' attached');

                ch.data.elapsedTime = 0;
                ch.setDataInterval(10);
                ch.setEnabled(true);
                ch.onError = onError;
            }
            function onButtonAttach(ch) {
                console.log(ch.name + ' attached');
                ch.onError = onError;
            }

            function stateChange(state) {
                console.log(state);
            }

            function valYChange(prop) {
                console.log(prop);
            }
            function valXChange(prop) {
                console.log(prop);
            }
            function posXChange(posChange, timeChange, indexTriggered) {
                currentX = Math.min(Math.max(currentX + posChange, 0), xMax);
                gotoPosition();
            }
            function posYChange(posChange, timeChange, indexTriggered) {
                currentY = Math.min(Math.max(currentY + posChange, 0), yMax);
                gotoPosition();
            }
            function endXTopReached(prop) {
                if (prop === true) {
                    currentX = 0;
                    gotoPosition();
                }
            }
            function endYTopReached(prop) {
                if (prop === true) {
                    currentY = 0;
                    gotoPosition();
                }
            }
            function endXBottomReached(prop) {
                if (prop === true) {
                    currentX = xMax;
                    gotoPosition();
                }
            }
            function endYBottomReached(prop) {
                if (prop === true) {
                    currentY = yMax;
                    gotoPosition();
                }
            }
            
            function resetCrosshairPosition(){
                crosshairScreenOffsetX = $("#scopeContainer").width() / 2;
                crosshairScreenOffsetY = $("#scopeContainer").height() / 2;
            }
            
            function getTarget(){
                for(var poi in jsonPois) {
                    distance = Math.sqrt(Math.pow((Math.abs(transformX) + crosshairScreenOffsetX - jsonPois[poi]["y"]), 2) + Math.pow((Math.abs(transformY) + crosshairScreenOffsetY - jsonPois[poi]["x"]), 2));
                    if(distance < jsonPois[poi]["radius"] / 2){
                        $("#target").html(jsonPois[poi]["uid"]);
                        return {
                            "distanceFactor": 1 - (distance / (jsonPois[poi]["radius"] / 2)),
                            "target": $("#poi-" + jsonPois[poi]["uid"]),
                            "datapoint": $("#datapoint-id-" + jsonPois[poi]["uid"])
                        };
                    }
                }
                $("#target").html("none");
            }
            
            function gotoPosition() {
                    
                resetCrosshairPosition();
                
                mapYmax = $("#overlay").height() - $("#scopeContainer").height() * 1;
                mapXmax = $("#overlay").width() - $("#scopeContainer").width() * 1;
                
                transformY = (currentY / yMax * mapYmax * -1);
                transformX = (currentX / xMax * mapXmax * -1);
                
                var target = getTarget();
                if(target){
                    if(target["distanceFactor"] > hysteresisFactor){
                        if(!target["target"].hasClass("active")){
                            target["target"].addClass("active");
                            target["datapoint"].addClass("active");
                            $(".content-holder").addClass("active");

                            // start video
                            target["datapoint"].find("video").each(function(i, video){
                                $(video)[0].autoplay = true;
                                $(video)[0].controls = false;
                                $(video)[0].loop = true;
                                $(video)[0].play();
                            });
                        }
                    }
                }else{
                    $(".poi.active").removeClass("active");
                    $(".datapoint.active").removeClass("active");
                    $(".content-holder").removeClass("active");
                    
                    // stop video
                    $(".content-holder video").each(function(i, video){
                        $(video)[0].pause();
                        $(video)[0].currentTime = 0;
                    });
                    
                }
                
                $("#overlay").css({
                    'transform': 'translate(' + transformX + 'px,' + transformY + 'px)'
                });
                
                
                if(debugmode){
                    $("#currentY").html(Math.abs(transformX) + crosshairScreenOffsetX);
                    $("#currentX").html(Math.abs(transformY) + crosshairScreenOffsetY);
                }
                
//                console.log("To Position: X-" + currentX / xMax + "  Y-" + currentY / yMax);
            }

            function onError(arg0, arg1) {
                console.log("ERROR: " + arg0 + " - " + arg1);
            }

        </script>
    </f:section>
</html>